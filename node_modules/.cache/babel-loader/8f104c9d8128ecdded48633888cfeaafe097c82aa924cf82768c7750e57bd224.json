{"ast":null,"code":"const EventEmitter = require(\"events\").EventEmitter;\nconst util = require(\"util\");\nlet driverType = null;\nfunction setDriverType(type) {\n  driverType = type;\n}\n\n// lazy load the C++ binding\nlet binding = null;\nfunction loadBinding() {\n  if (!binding) {\n    const options = require('./binding-options');\n    if (process.platform === \"linux\" && (!driverType || driverType === \"hidraw\")) {\n      options.name = 'HID_hidraw';\n    }\n    binding = require(\"pkg-prebuilds/bindings\")(__dirname, options);\n  }\n}\n\n//This class is a wrapper for `binding.HID` class\nfunction HID() {\n  // see issue #150 (enhancement, solves issue #149)\n  // throw an error for those who forget to instantiate, i.e. by \"*new* HID.HID()\"\n  // and who would otherwise be left trying to figure out why \"self.on is not a function\"\n  if (!new.target) {\n    throw new Error('HID() must be called with \\'new\\' operator');\n  }\n\n  //Inherit from EventEmitter\n  EventEmitter.call(this);\n  loadBinding();\n\n  /* We also want to inherit from `binding.HID`, but unfortunately,\n      it's not so easy for native Objects. For example, the\n      following won't work since `new` keyword isn't used:\n      `binding.HID.apply(this, arguments);`\n      So... we do this craziness instead...\n  */\n  var thisPlusArgs = new Array(arguments.length + 1);\n  thisPlusArgs[0] = null;\n  for (var i = 0; i < arguments.length; i++) thisPlusArgs[i + 1] = arguments[i];\n  this._raw = new (Function.prototype.bind.apply(binding.HID, thisPlusArgs))();\n\n  /* Now we have `this._raw` Object from which we need to\n      inherit.  So, one solution is to simply copy all\n      prototype methods over to `this` and binding them to\n      `this._raw`\n  */\n  for (var i in binding.HID.prototype) this[i] = binding.HID.prototype[i].bind(this._raw);\n\n  /* We are now done inheriting from `binding.HID` and EventEmitter.\n      Now upon adding a new listener for \"data\" events, we start\n      polling the HID device using `read(...)`\n      See `resume()` for more details. */\n  this._paused = true;\n  var self = this;\n  self.on(\"newListener\", function (eventName, listener) {\n    if (eventName == \"data\") process.nextTick(self.resume.bind(self));\n  });\n}\n//Inherit prototype methods\nutil.inherits(HID, EventEmitter);\n//Don't inherit from `binding.HID`; that's done above already!\n\nHID.prototype.close = function close() {\n  this._closing = true;\n  this.removeAllListeners();\n  this._raw.close();\n  this._closed = true;\n};\n//Pauses the reader, which stops \"data\" events from being emitted\nHID.prototype.pause = function pause() {\n  this._paused = true;\n};\nHID.prototype.read = function read(callback) {\n  if (this._closed) {\n    throw new Error('Unable to read from a closed HID device');\n  } else {\n    return this._raw.read(callback);\n  }\n};\nHID.prototype.resume = function resume() {\n  var self = this;\n  if (self._paused && self.listeners(\"data\").length > 0) {\n    //Start polling & reading loop\n    self._paused = false;\n    self.read(function readFunc(err, data) {\n      try {\n        if (err) {\n          //Emit error and pause reading\n          self._paused = true;\n          if (!self._closing) self.emit(\"error\", err);\n          //else ignore any errors if I'm closing the device\n        } else {\n          //If there are no \"data\" listeners, we pause\n          if (self.listeners(\"data\").length <= 0) self._paused = true;\n          //Keep reading if we aren't paused\n          if (!self._paused) self.read(readFunc);\n          //Now emit the event\n          self.emit(\"data\", data);\n        }\n      } catch (e) {\n        // Emit an error on the device instead of propagating to a c++ exception\n        setImmediate(() => {\n          self.emit(\"error\", e);\n        });\n      }\n    });\n  }\n};\nclass HIDAsync extends EventEmitter {\n  constructor(raw) {\n    super();\n    if (!(raw instanceof binding.HIDAsync)) {\n      throw new Error(`HIDAsync cannot be constructed directly. Use HIDAsync.open() instead`);\n    }\n    this._raw = raw;\n\n    /* Now we have `this._raw` Object from which we need to\n        inherit.  So, one solution is to simply copy all\n        prototype methods over to `this` and binding them to\n        `this._raw`.\n        We explicitly wrap them in an async method, to ensure \n        that any thrown errors are promise rejections\n    */\n    for (let i in this._raw) {\n      this[i] = async (...args) => this._raw[i](...args);\n    }\n\n    /* Now upon adding a new listener for \"data\" events, we start\n        the read thread executing. See `resume()` for more details.\n    */\n    this.on(\"newListener\", (eventName, listener) => {\n      if (eventName == \"data\") process.nextTick(this.resume.bind(this));\n    });\n    this.on(\"removeListener\", (eventName, listener) => {\n      if (eventName == \"data\" && this.listenerCount(\"data\") == 0) process.nextTick(this.pause.bind(this));\n    });\n  }\n  static async open(...args) {\n    loadBinding();\n    const native = await binding.openAsyncHIDDevice(...args);\n    return new HIDAsync(native);\n  }\n  async close() {\n    this._closing = true;\n    this.removeAllListeners();\n    await this._raw.close();\n    this._closed = true;\n  }\n\n  //Pauses the reader, which stops \"data\" events from being emitted\n  pause() {\n    this._raw.readStop();\n  }\n  resume() {\n    if (this.listenerCount(\"data\") > 0) {\n      //Start polling & reading loop\n      this._raw.readStart((err, data) => {\n        try {\n          if (err) {\n            if (!this._closing) this.emit(\"error\", err);\n            //else ignore any errors if I'm closing the device\n          } else {\n            this.emit(\"data\", data);\n          }\n        } catch (e) {\n          // Emit an error on the device instead of propagating to a c++ exception\n          setImmediate(() => {\n            this.emit(\"error\", e);\n          });\n        }\n      });\n    }\n  }\n}\nfunction showdevices() {\n  loadBinding();\n  return binding.devices.apply(HID, arguments);\n}\nfunction showdevicesAsync(...args) {\n  loadBinding();\n  return binding.devicesAsync(...args);\n}\n\n//Expose API\nexports.HID = HID;\nexports.HIDAsync = HIDAsync;\nexports.devices = showdevices;\nexports.devicesAsync = showdevicesAsync;\nexports.setDriverType = setDriverType;","map":{"version":3,"names":["EventEmitter","require","util","driverType","setDriverType","type","binding","loadBinding","options","process","platform","name","__dirname","HID","new","target","Error","call","thisPlusArgs","Array","arguments","length","i","_raw","Function","prototype","bind","apply","_paused","self","on","eventName","listener","nextTick","resume","inherits","close","_closing","removeAllListeners","_closed","pause","read","callback","listeners","readFunc","err","data","emit","e","setImmediate","HIDAsync","constructor","raw","args","listenerCount","open","native","openAsyncHIDDevice","readStop","readStart","showdevices","devices","showdevicesAsync","devicesAsync","exports"],"sources":["/Users/parkerhuang/Desktop/projects/books/node_modules/node-hid/nodehid.js"],"sourcesContent":["\nconst EventEmitter = require(\"events\").EventEmitter;\nconst util = require(\"util\");\n\nlet driverType = null;\nfunction setDriverType(type) {\n    driverType = type;\n}\n\n// lazy load the C++ binding\nlet binding = null;\nfunction loadBinding() {\n    if (!binding) {\n        const options = require('./binding-options');\n        if (process.platform === \"linux\" && (!driverType || driverType === \"hidraw\")) {\n            options.name = 'HID_hidraw';\n        }\n        binding = require(\"pkg-prebuilds/bindings\")(__dirname, options);\n    }\n}\n\n//This class is a wrapper for `binding.HID` class\nfunction HID() {\n\n    // see issue #150 (enhancement, solves issue #149)\n    // throw an error for those who forget to instantiate, i.e. by \"*new* HID.HID()\"\n    // and who would otherwise be left trying to figure out why \"self.on is not a function\"\n    if (!new.target) {\n        throw new Error('HID() must be called with \\'new\\' operator');\n    }\n\n    //Inherit from EventEmitter\n    EventEmitter.call(this);\n\n    loadBinding();\n\n    /* We also want to inherit from `binding.HID`, but unfortunately,\n        it's not so easy for native Objects. For example, the\n        following won't work since `new` keyword isn't used:\n        `binding.HID.apply(this, arguments);`\n        So... we do this craziness instead...\n    */\n    var thisPlusArgs = new Array(arguments.length + 1);\n    thisPlusArgs[0] = null;\n    for(var i = 0; i < arguments.length; i++)\n        thisPlusArgs[i + 1] = arguments[i];\n    this._raw = new (Function.prototype.bind.apply(binding.HID,\n        thisPlusArgs) )();\n\n    /* Now we have `this._raw` Object from which we need to\n        inherit.  So, one solution is to simply copy all\n        prototype methods over to `this` and binding them to\n        `this._raw`\n    */\n    for(var i in binding.HID.prototype)\n        this[i] = binding.HID.prototype[i].bind(this._raw);\n\n    /* We are now done inheriting from `binding.HID` and EventEmitter.\n        Now upon adding a new listener for \"data\" events, we start\n        polling the HID device using `read(...)`\n        See `resume()` for more details. */\n    this._paused = true;\n    var self = this;\n    self.on(\"newListener\", function(eventName, listener) {\n        if(eventName == \"data\")\n            process.nextTick(self.resume.bind(self) );\n    });\n}\n//Inherit prototype methods\nutil.inherits(HID, EventEmitter);\n//Don't inherit from `binding.HID`; that's done above already!\n\nHID.prototype.close = function close() {\n    this._closing = true;\n    this.removeAllListeners();\n    this._raw.close();\n    this._closed = true;\n};\n//Pauses the reader, which stops \"data\" events from being emitted\nHID.prototype.pause = function pause() {\n    this._paused = true;\n};\n\nHID.prototype.read = function read(callback) {\n    if (this._closed) {\n    throw new Error('Unable to read from a closed HID device');\n  } else {\n    return this._raw.read(callback);\n  }\n};\n\nHID.prototype.resume = function resume() {\n    var self = this;\n    if(self._paused && self.listeners(\"data\").length > 0)\n    {\n        //Start polling & reading loop\n        self._paused = false;\n        self.read(function readFunc(err, data) {\n            try {\n                if(err)\n                {\n                    //Emit error and pause reading\n                    self._paused = true;\n                    if(!self._closing)\n                        self.emit(\"error\", err);\n                    //else ignore any errors if I'm closing the device\n                }\n                else\n                {\n                    //If there are no \"data\" listeners, we pause\n                    if(self.listeners(\"data\").length <= 0)\n                        self._paused = true;\n                    //Keep reading if we aren't paused\n                    if(!self._paused)\n                        self.read(readFunc);\n                    //Now emit the event\n                    self.emit(\"data\", data);\n                }\n            } catch (e) {\n                // Emit an error on the device instead of propagating to a c++ exception\n                setImmediate(() => {\n                    self.emit(\"error\", e);\n                });\n            }\n        });\n    }\n};\n\nclass HIDAsync extends EventEmitter {\n    constructor(raw) {\n        super()\n\n        if (!(raw instanceof binding.HIDAsync)) {\n            throw new Error(`HIDAsync cannot be constructed directly. Use HIDAsync.open() instead`)\n        }\n\n        this._raw = raw\n\n        /* Now we have `this._raw` Object from which we need to\n            inherit.  So, one solution is to simply copy all\n            prototype methods over to `this` and binding them to\n            `this._raw`.\n            We explicitly wrap them in an async method, to ensure \n            that any thrown errors are promise rejections\n        */\n        for (let i in this._raw) {\n            this[i] = async (...args) => this._raw[i](...args);\n        }\n\n        /* Now upon adding a new listener for \"data\" events, we start\n            the read thread executing. See `resume()` for more details.\n        */\n        this.on(\"newListener\", (eventName, listener) =>{\n            if(eventName == \"data\")\n                process.nextTick(this.resume.bind(this) );\n        });\n        this.on(\"removeListener\", (eventName, listener) => {\n            if(eventName == \"data\" && this.listenerCount(\"data\") == 0)\n                process.nextTick(this.pause.bind(this) );\n        })\n    }\n\n    static async open(...args) {\n        loadBinding();\n        const native = await binding.openAsyncHIDDevice(...args);\n        return new HIDAsync(native)\n    }\n\n    async close() {\n        this._closing = true;\n        this.removeAllListeners();\n        await this._raw.close();\n        this._closed = true;\n    }\n    \n    //Pauses the reader, which stops \"data\" events from being emitted\n    pause() {\n        this._raw.readStop();\n    }\n\n    resume() {\n        if(this.listenerCount(\"data\") > 0)\n        {\n            //Start polling & reading loop\n            this._raw.readStart((err, data) => {\n                try {\n                    if (err) {\n                        if(!this._closing)\n                            this.emit(\"error\", err);\n                        //else ignore any errors if I'm closing the device\n                    } else {\n                        this.emit(\"data\", data);\n                    }\n                } catch (e) {\n                    // Emit an error on the device instead of propagating to a c++ exception\n                    setImmediate(() => {\n                        this.emit(\"error\", e);\n                    });\n                }\n            })\n        }\n    }\n}\n\nfunction showdevices() {\n    loadBinding();\n    return binding.devices.apply(HID,arguments);\n}\n\nfunction showdevicesAsync(...args) {\n    loadBinding();\n    return binding.devicesAsync(...args);\n}\n\n\n//Expose API\nexports.HID = HID;\nexports.HIDAsync = HIDAsync;\nexports.devices = showdevices;\nexports.devicesAsync = showdevicesAsync;\nexports.setDriverType = setDriverType;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}