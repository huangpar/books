{"ast":null,"code":"// SORRY THE SOURCE IS DOUBLE INCLUDED \n// Blame the maintainers of node.js and the brainfucked build-oriented hell they\n// created in order to plug into massive corporate build systems who don't intend \n// on using node for anything but UI coding and pipe glue. Spoiler: doing types\n// in Rust is not going to change anything. It was always FUD that ends with C#.\n// RANT OVER\nimport * as sift from 'sift';\nexport const forAllEmissionsInPool = function (array, poolSize, callback, complete) {\n  var a = {\n    count: 0\n  };\n  var collection = array;\n  var queue = [];\n  var activeCount = 0;\n  var returnArgs = [];\n  var begin = function (action) {\n    if (a.count >= poolSize) {\n      queue.push(action);\n    } else {\n      a.count++;\n      action();\n    }\n  };\n  var finish = function (index, args) {\n    if (args.length == 1) returnArgs[index] = args[0];\n    if (args.length > 1) returnArgs[index] = args;\n    a.count--;\n    if (queue.length > 0) {\n      a.count++;\n      queue.shift()();\n    } else if (a.count == 0 && complete) complete.apply(complete, returnArgs);\n  };\n  Array.prototype.forEach.apply(array, [function (value, key) {\n    begin(function () {\n      callback(value, key, function () {\n        finish(key, Array.prototype.slice.apply(arguments, [0]));\n      });\n    });\n  }]);\n  if (a.count == 0 && complete) complete.apply(complete, returnArgs);\n};\nexport const forAllEmissions = function (list, callback, complete) {\n  var ref = {\n    count: 0\n  };\n  Array.prototype.forEach.apply(list, [function (value, key) {\n    ref.count++;\n    setTimeout(function () {\n      callback(value, key, function () {\n        ref.count--;\n        if (ref.count < 0) throw new Error('continued iterating past stop');\n        if (ref.count == 0) return complete();\n      });\n    }, 1);\n  }]);\n  if (!list.length) complete();\n};\nexport const mapEmissions = function (list, callback, complete, parallel) {\n  var results = [];\n  var fnName = parallel ? 'forAllEmissions' : 'forEachEmission';\n  asyncarray[fnName](list, function (item, index, done) {\n    callback(item, function (item) {\n      if (item) results.push(item);\n      done();\n    });\n  }, function () {\n    complete(results);\n  });\n};\nexport const forEachEmission = function (array, callback, complete) {\n  var a = {\n    count: 0\n  };\n  var collection = array;\n  var returnArgs = [];\n  var len = collection.length;\n  var fn = function (collection, callback, complete) {\n    if (a.count >= collection.length) {\n      setTimeout(function () {\n        if (complete) complete.apply(complete, returnArgs);\n      }, 1);\n      return;\n    } else {\n      setTimeout(function () {\n        callback(collection[a.count], a.count, function () {\n          var args = Array.prototype.slice.apply(arguments, [0]);\n          if (args.length == 1) returnArgs[a.count] = args[0];\n          if (args.length > 1) returnArgs[a.count] = args;\n          a.count++;\n          fn(collection, callback, complete);\n        });\n      }, 1);\n    }\n  };\n  fn(collection, callback, complete);\n};\nexport const uForEach = function (array, callback) {\n  var len = array.length;\n  for (var j = 0; j < len; j++) {\n    callback(array[j], j);\n  }\n};\nexport const combine = function (thisArray, thatArray) {\n  //parallel\n  var result = [];\n  Array.prototype.forEach.apply(thisArray, [function (value, key) {\n    if (result.indexOf[value] === -1) result.push(value);\n  }]);\n  Array.prototype.forEach.apply(thatArray, [function (value, key) {\n    if (result.indexOf[value] === -1) result.push(value);\n  }]);\n  return result;\n};\nexport const contains = function (haystack, needle) {\n  if (typeof needle == 'array') {\n    result = false;\n    Array.prototype.forEach.apply(needle, [function (pin) {\n      result = result || object.contains(haystack, pin);\n    }]);\n    return result;\n  } else return haystack.indexOf(needle) != -1;\n};\nexport const delta = function (a, b) {\n  var delta = [];\n  Array.prototype.forEach.apply(a, [function (item) {\n    if (b.indexOf(item) != -1) delta.push(item);\n  }]);\n  Array.prototype.forEach.apply(b, [function (item) {\n    if (a.indexOf(item) != -1 && delta.indexOf(item) == -1) delta.push(item);\n  }]);\n  return delta;\n};\n\n//mutators (return modified elements)\nexport const erase = function (arr, field) {\n  if (typeof field != 'object') {\n    var index;\n    var item;\n    while ((index = arr.indexOf(field)) != -1) {\n      //get 'em all\n      item = arr[index];\n      arr.splice(index, 1); //delete the one we found\n    }\n    return item;\n  } else {\n    var filter = sift(field);\n    var filtered = [];\n    for (var i = arr.length; i--;) {\n      if (filter.test(arr[i])) {\n        filtered.push(arr[i]);\n        arr.splice(i, 1);\n      }\n    }\n    return filtered;\n  }\n};\nexport const empty = function (arr) {\n  var removed = arr.slice(0);\n  arr.splice(0, arr.length);\n  return removed;\n};\nexport const proto = function () {\n  if (!Array.prototype.uForEach) Array.prototype.uForEach = function (callback) {\n    return asyncarray.uForEach(this, callback);\n  };\n\n  // allows you to act on each member in an array one at a time \n  // (while being able to perform asynchronous tasks internally)\n  if (!Array.prototype.forEachEmission) {\n    Array.prototype.forEachEmission = function (callback, complete) {\n      return forEachEmission(this, callback, complete);\n    };\n  }\n\n  //allows you to act on each member in a chain in parallel\n  if (!Array.prototype.forAllEmissions) {\n    Array.prototype.forAllEmissions = function (callback, complete) {\n      return forAllEmissions(this, callback, complete);\n    };\n  }\n\n  //allows you to act on each member in a pool, with a maximum number of active jobs until complete\n  if (!Array.prototype.forAllEmissionsInPool) {\n    Array.prototype.forAllEmissionsInPool = function (poolSize, callback, complete) {\n      return forAllEmissionsInPool(this, poolSize, callback, complete);\n    };\n  }\n\n  //map an array, asynchronously\n  if (!Array.prototype.mapEmissions) {\n    Array.prototype.mapEmissions = function (poolSize, callback, complete) {\n      return mapEmissions(this, poolSize, callback, complete);\n    };\n  }\n  if (!Array.prototype.combine) Array.prototype.combine = function (array) {\n    return combine(this, array);\n  };\n  if (!Array.prototype.contains) Array.prototype.contains = function (item) {\n    return contains(this, item);\n  };\n  if (!Array.prototype.erase) Array.prototype.erase = function (field) {\n    return erase(this, field);\n  };\n  if (!Array.prototype.empty) Array.prototype.empty = function (field) {\n    return empty(this, field);\n  };\n};\nexport const forEachBatch = forAllEmissionsInPool;\nexport const forEach = forAllEmissionsInPool;\nexport const forAll = forAllEmissionsInPool;\nexport const map = mapEmissions;\nmap.each = function (list, callback, complete) {\n  return asyncarray.mapEmissions(list, callback, complete);\n};\nmap.all = function (list, callback, complete) {\n  return asyncarray.mapEmissions(list, callback, complete, true);\n};","map":{"version":3,"names":["sift","forAllEmissionsInPool","array","poolSize","callback","complete","a","count","collection","queue","activeCount","returnArgs","begin","action","push","finish","index","args","length","shift","apply","Array","prototype","forEach","value","key","slice","arguments","forAllEmissions","list","ref","setTimeout","Error","mapEmissions","parallel","results","fnName","asyncarray","item","done","forEachEmission","len","fn","uForEach","j","combine","thisArray","thatArray","result","indexOf","contains","haystack","needle","pin","object","delta","b","erase","arr","field","splice","filter","filtered","i","test","empty","removed","proto","forEachBatch","forAll","map","each","all"],"sources":["/Users/parkerhuang/Desktop/projects/books/node_modules/async-arrays/async-arrays.mjs"],"sourcesContent":["// SORRY THE SOURCE IS DOUBLE INCLUDED \n// Blame the maintainers of node.js and the brainfucked build-oriented hell they\n// created in order to plug into massive corporate build systems who don't intend \n// on using node for anything but UI coding and pipe glue. Spoiler: doing types\n// in Rust is not going to change anything. It was always FUD that ends with C#.\n// RANT OVER\nimport * as sift from 'sift';\n\nexport const forAllEmissionsInPool = function(array, poolSize, callback, complete){\n    var a = {count : 0};\n    var collection = array;\n    var queue = [];\n    var activeCount = 0;\n    var returnArgs = [];\n    var begin = function(action){\n        if(a.count >= poolSize){\n            queue.push(action)\n        }else{\n            a.count++;\n            action();\n        }\n    };\n    var finish = function(index, args){\n        if(args.length == 1) returnArgs[index] = args[0];\n        if(args.length > 1) returnArgs[index] = args;\n        a.count--;\n        if(queue.length > 0){\n            a.count++;\n            queue.shift()();\n        }else if(a.count == 0 && complete) complete.apply(complete, returnArgs);\n    };\n    Array.prototype.forEach.apply(array, [function(value, key){\n        begin(function(){\n            callback(value, key, function(){\n               finish(key, Array.prototype.slice.apply(arguments, [0])); \n            });\n        });\n    }]);\n    if(a.count == 0 && complete) complete.apply(complete, returnArgs);\n};\n\nexport const forAllEmissions = function(list, callback, complete){\n    var ref = {count : 0};\n    Array.prototype.forEach.apply(list, [function(value, key){\n        ref.count++;\n        setTimeout(function(){\n            callback(value, key, function(){\n                    ref.count--;\n                    if(ref.count < 0) throw new Error('continued iterating past stop');\n                    if(ref.count == 0) return complete();\n            });\n        },1);\n    }]);\n    if(!list.length) complete();\n};\n\nexport const mapEmissions = function(list, callback, complete, parallel){\n    var results = [];\n    var fnName = parallel?'forAllEmissions':'forEachEmission';\n    asyncarray[fnName](list, function(item, index, done){\n        callback(item, function(item){\n           if(item) results.push(item);\n           done();\n        });\n    }, function(){\n        complete(results);\n    });\n};\n\nexport const forEachEmission = function(array, callback, complete){\n    var a = {count : 0};\n    var collection = array;\n    var returnArgs = [];\n    var len = collection.length;\n    var fn = function(collection, callback, complete){\n        if(a.count >= collection.length){\n            setTimeout(function(){\n                if(complete) complete.apply(complete, returnArgs);\n            },1); return;\n        }else{\n            setTimeout(function(){\n                callback(collection[a.count], a.count, function(){\n                    var args = Array.prototype.slice.apply(arguments, [0]);\n                    if(args.length == 1) returnArgs[a.count] = args[0];\n                    if(args.length > 1) returnArgs[a.count] = args;\n                    a.count++;\n                    fn(collection, callback, complete);\n                });\n            },1);\n        }\n    };\n    fn(collection, callback, complete);\n};\n\nexport const uForEach = function(array, callback){\n    var len = array.length;\n    for (var j = 0; j < len; j++) {\n        callback(array[j], j);\n    }\n};\n\nexport const combine = function(thisArray, thatArray){ //parallel\n    var result = [];\n    Array.prototype.forEach.apply(thisArray, [function(value, key){\n        if(result.indexOf[value] === -1) result.push(value);\n    }]);\n    Array.prototype.forEach.apply(thatArray, [function(value, key){\n        if(result.indexOf[value] === -1) result.push(value);\n    }]);\n    return result;\n};\n\nexport const contains = function(haystack, needle){\n    if(typeof needle == 'array'){\n        result = false;\n        Array.prototype.forEach.apply(needle, [function(pin){\n            result = result || object.contains(haystack, pin);\n        }]);\n        return result;\n    }\n    else return haystack.indexOf(needle) != -1;\n};\n\nexport const delta = function(a, b){\n    var delta = [];\n    Array.prototype.forEach.apply(a, [function(item){\n        if(b.indexOf(item) != -1) delta.push(item);\n    }]);\n    Array.prototype.forEach.apply(b, [function(item){\n        if(a.indexOf(item) != -1 && delta.indexOf(item) == -1) delta.push(item);\n    }]);\n    return delta;\n};\n\n//mutators (return modified elements)\nexport const erase = function(arr, field){\n    if(typeof field != 'object'){\n        var index;\n        var item;\n        while((index = arr.indexOf(field)) != -1){ //get 'em all\n            item = arr[index];\n            arr.splice(index, 1); //delete the one we found\n        }\n        return item;\n    }else{\n        var filter = sift(field);\n        var filtered = [];\n        for(var i = arr.length; i--; ){\n            if(filter.test(arr[i])){\n                filtered.push(arr[i]);\n                arr.splice(i, 1);\n            }\n        }\n        return filtered;\n    }\n};\n\nexport const empty = function(arr){\n    var removed = arr.slice(0);\n    arr.splice(0, arr.length);\n    return removed;\n};\n\nexport const proto = function(){\n    if(!Array.prototype.uForEach) Array.prototype.uForEach = function(callback){\n        return asyncarray.uForEach(this, callback);\n    };\n\n    // allows you to act on each member in an array one at a time \n    // (while being able to perform asynchronous tasks internally)\n    if(!Array.prototype.forEachEmission){\n        Array.prototype.forEachEmission = function(callback, complete){\n            return forEachEmission(this, callback, complete);\n        };\n    }\n\n    //allows you to act on each member in a chain in parallel\n    if(!Array.prototype.forAllEmissions){\n        Array.prototype.forAllEmissions = function(callback, complete){\n            return forAllEmissions(this, callback, complete);\n        };\n    }\n\n    //allows you to act on each member in a pool, with a maximum number of active jobs until complete\n    if(!Array.prototype.forAllEmissionsInPool){\n        Array.prototype.forAllEmissionsInPool = function(poolSize, callback, complete){\n            return forAllEmissionsInPool(this, poolSize, callback, complete);\n        };\n    }\n    \n    //map an array, asynchronously\n    if(!Array.prototype.mapEmissions){\n        Array.prototype.mapEmissions = function(poolSize, callback, complete){\n            return mapEmissions(this, poolSize, callback, complete);\n        };\n    }\n    if(!Array.prototype.combine) Array.prototype.combine = function(array){\n        return combine(this, array);\n    };\n    if(!Array.prototype.contains) Array.prototype.contains = function(item){\n        return contains(this, item);\n    };\n    if(!Array.prototype.erase) Array.prototype.erase = function(field){\n        return erase(this, field);\n    };\n    if(!Array.prototype.empty) Array.prototype.empty = function(field){\n        return empty(this, field);\n    };\n};\n\nexport const forEachBatch = forAllEmissionsInPool\nexport const forEach = forAllEmissionsInPool\nexport const forAll = forAllEmissionsInPool\nexport const map = mapEmissions\nmap.each = function(list, callback, complete){\n    return asyncarray.mapEmissions(list, callback, complete);\n}\nmap.all = function(list, callback, complete){\n    return asyncarray.mapEmissions(list, callback, complete, true);\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}