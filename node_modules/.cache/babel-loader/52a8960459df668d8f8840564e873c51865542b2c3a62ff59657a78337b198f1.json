{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PacketLengthParser = void 0;\nconst stream_1 = require(\"stream\");\n/**\n * A transform stream that decodes packets with a delimiter and length of payload\n * specified within the data stream.\n * @extends Transform\n * @summary Decodes packets of the general form:\n *       [delimiter][len][payload0] ... [payload0 + len]\n *\n * The length field can be up to 4 bytes and can be at any offset within the packet\n *       [delimiter][header0][header1][len0][len1[payload0] ... [payload0 + len]\n *\n * The offset and number of bytes of the length field need to be provided in options\n * if not 1 byte immediately following the delimiter.\n */\nclass PacketLengthParser extends stream_1.Transform {\n  buffer;\n  start;\n  opts;\n  constructor(options = {}) {\n    super(options);\n    const {\n      delimiter = [0xaa],\n      delimiterBytes = 1,\n      packetOverhead = 2,\n      lengthBytes = 1,\n      lengthOffset = 1,\n      maxLen = 0xff\n    } = options;\n    this.opts = {\n      delimiter: [].concat(delimiter),\n      delimiterBytes,\n      packetOverhead,\n      lengthBytes,\n      lengthOffset,\n      maxLen\n    };\n    this.buffer = Buffer.alloc(0);\n    this.start = false;\n  }\n  _transform(chunk, encoding, cb) {\n    for (let ndx = 0; ndx < chunk.length; ndx++) {\n      const byte = chunk[ndx];\n      if (true === this.start) {\n        this.buffer = Buffer.concat([this.buffer, Buffer.from([byte])]);\n        if (this.buffer.length >= this.opts.lengthOffset + this.opts.lengthBytes) {\n          const len = this.buffer.readUIntLE(this.opts.lengthOffset, this.opts.lengthBytes);\n          if (this.buffer.length == len + this.opts.packetOverhead || len > this.opts.maxLen) {\n            this.push(this.buffer);\n            this.buffer = Buffer.alloc(0);\n            this.start = false;\n          }\n        }\n      } else {\n        this.buffer = Buffer.concat([Buffer.from([byte]), this.buffer]);\n        if (this.buffer.length === this.opts.delimiterBytes) {\n          const delimiter = this.buffer.readUIntLE(0, this.opts.delimiterBytes);\n          if (this.opts.delimiter.includes(delimiter)) {\n            this.start = true;\n            this.buffer = Buffer.from([...this.buffer].reverse());\n          } else {\n            this.buffer = Buffer.from(this.buffer.subarray(1, this.buffer.length));\n          }\n        }\n      }\n    }\n    cb();\n  }\n  _flush(cb) {\n    this.push(this.buffer);\n    this.buffer = Buffer.alloc(0);\n    cb();\n  }\n}\nexports.PacketLengthParser = PacketLengthParser;","map":{"version":3,"names":["Object","defineProperty","exports","value","PacketLengthParser","stream_1","require","Transform","buffer","start","opts","constructor","options","delimiter","delimiterBytes","packetOverhead","lengthBytes","lengthOffset","maxLen","concat","Buffer","alloc","_transform","chunk","encoding","cb","ndx","length","byte","from","len","readUIntLE","push","includes","reverse","subarray","_flush"],"sources":["/Users/parkerhuang/Desktop/projects/books/node_modules/@serialport/parser-packet-length/dist/index.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PacketLengthParser = void 0;\nconst stream_1 = require(\"stream\");\n/**\n * A transform stream that decodes packets with a delimiter and length of payload\n * specified within the data stream.\n * @extends Transform\n * @summary Decodes packets of the general form:\n *       [delimiter][len][payload0] ... [payload0 + len]\n *\n * The length field can be up to 4 bytes and can be at any offset within the packet\n *       [delimiter][header0][header1][len0][len1[payload0] ... [payload0 + len]\n *\n * The offset and number of bytes of the length field need to be provided in options\n * if not 1 byte immediately following the delimiter.\n */\nclass PacketLengthParser extends stream_1.Transform {\n    buffer;\n    start;\n    opts;\n    constructor(options = {}) {\n        super(options);\n        const { delimiter = [0xaa], delimiterBytes = 1, packetOverhead = 2, lengthBytes = 1, lengthOffset = 1, maxLen = 0xff } = options;\n        this.opts = {\n            delimiter: [].concat(delimiter),\n            delimiterBytes,\n            packetOverhead,\n            lengthBytes,\n            lengthOffset,\n            maxLen,\n        };\n        this.buffer = Buffer.alloc(0);\n        this.start = false;\n    }\n    _transform(chunk, encoding, cb) {\n        for (let ndx = 0; ndx < chunk.length; ndx++) {\n            const byte = chunk[ndx];\n            if (true === this.start) {\n                this.buffer = Buffer.concat([this.buffer, Buffer.from([byte])]);\n                if (this.buffer.length >= this.opts.lengthOffset + this.opts.lengthBytes) {\n                    const len = this.buffer.readUIntLE(this.opts.lengthOffset, this.opts.lengthBytes);\n                    if (this.buffer.length == len + this.opts.packetOverhead || len > this.opts.maxLen) {\n                        this.push(this.buffer);\n                        this.buffer = Buffer.alloc(0);\n                        this.start = false;\n                    }\n                }\n            }\n            else {\n                this.buffer = Buffer.concat([Buffer.from([byte]), this.buffer]);\n                if (this.buffer.length === this.opts.delimiterBytes) {\n                    const delimiter = this.buffer.readUIntLE(0, this.opts.delimiterBytes);\n                    if (this.opts.delimiter.includes(delimiter)) {\n                        this.start = true;\n                        this.buffer = Buffer.from([...this.buffer].reverse());\n                    }\n                    else {\n                        this.buffer = Buffer.from(this.buffer.subarray(1, this.buffer.length));\n                    }\n                }\n            }\n        }\n        cb();\n    }\n    _flush(cb) {\n        this.push(this.buffer);\n        this.buffer = Buffer.alloc(0);\n        cb();\n    }\n}\nexports.PacketLengthParser = PacketLengthParser;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}